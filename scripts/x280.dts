/dts-v1/;

/ {
    #address-cells = <0x2>;
    #size-cells = <0x2>;
    compatible = "tt,whisper";
    chosen {
        bootargs = "rw console=hvc0 earlycon=sbi panic=-1 root=/dev/pmem0";
    };
    cpus {
        #address-cells = <0x1>;
        #size-cells = <0x0>;
        timebase-frequency = <50000000>;
        cpu@0 {
            device_type = "cpu";
            reg = <0x0>;
            status = "okay";
            compatible = "riscv";
            riscv,isa = "rv64imafdcv_zicsr_zifencei_zfh_zba_zbb_zvfh_sscofpmf";
            mmu-type = "riscv,sv57";
            riscv,pmpregions = <0x10>;
            riscv,pmpgranularity = <0x4>;
            clock-frequency = <0x3B9ACA00>;
            riscv,cboz-block-size = <0x40>;
            cpu0_intc: interrupt-controller {
                compatible = "riscv,cpu-intc";
                interrupt-controller;
                #interrupt-cells = <1>;
            };
        };
        cpu@1 {
            device_type = "cpu";
            reg = <0x1>;
            status = "okay";
            compatible = "riscv";
            riscv,isa = "rv64imafdcv_zicsr_zifencei_zfh_zba_zbb_zvfh_sscofpmf";
            mmu-type = "riscv,sv57";
            riscv,pmpregions = <0x10>;
            riscv,pmpgranularity = <0x4>;
            clock-frequency = <0x3B9ACA00>;
            riscv,cboz-block-size = <0x40>;
            cpu1_intc: interrupt-controller {
                compatible = "riscv,cpu-intc";
                interrupt-controller;
                #interrupt-cells = <1>;
            };
        };
        cpu@2 {
            device_type = "cpu";
            reg = <0x2>;
            status = "okay";
            compatible = "riscv";
            riscv,isa = "rv64imafdcv_zicsr_zifencei_zfh_zba_zbb_zvfh_sscofpmf";
            mmu-type = "riscv,sv57";
            riscv,pmpregions = <0x10>;
            riscv,pmpgranularity = <0x4>;
            clock-frequency = <0x3B9ACA00>;
            riscv,cboz-block-size = <0x40>;
            cpu2_intc: interrupt-controller {
                compatible = "riscv,cpu-intc";
                interrupt-controller;
                #interrupt-cells = <1>;
            };
        };
        cpu@3 {
            device_type = "cpu";
            reg = <0x3>;
            status = "okay";
            compatible = "riscv";
            riscv,isa = "rv64imafdcv_zicsr_zifencei_zfh_zba_zbb_zvfh_sscofpmf";
            mmu-type = "riscv,sv57";
            riscv,pmpregions = <0x10>;
            riscv,pmpgranularity = <0x4>;
            clock-frequency = <0x3B9ACA00>;
            riscv,cboz-block-size = <0x40>;
            cpu3_intc: interrupt-controller {
                compatible = "riscv,cpu-intc";
                interrupt-controller;
                #interrupt-cells = <1>;
            };
        };



    };
    // Memory limited to 2896MB cause last 1200MB for rootfs
    memory@0 {
        device_type = "memory";
        reg = <0x4000 0x30000000 0x0 0xb5000000>;
    };

    // Last 1200MB of 4G Memory used for rootfs
    // PMEM regions are not part of 'memory'
    // 1200MB for rootfs
    // endpoint of memory@0 cell has to be adjusted accordingly
    pmem@2896 {
        compatible = "pmem-region";
        reg = <0x4000 0xe5000000 0x0 0x4b000000>;
    };

    soc {
        #address-cells = <0x2>;
        #size-cells = <0x2>;
        compatible = "simple-bus";
        ranges;

        clint: timer@2000000 {
            compatible = "riscv,clint0";
            reg = <0x0 0x2000000 0x0 0x10000>;
            // 3 = software interrupt
            // 7 = timer interrupt
            interrupts-extended = <&cpu0_intc 0x3>, <&cpu0_intc 0x7>, <&cpu1_intc 0x3>, <&cpu1_intc 0x7>,
                                  <&cpu2_intc 0x3>, <&cpu2_intc 0x7>, <&cpu3_intc 0x3>, <&cpu3_intc 0x7>;
        };

        plic: interrupt-controller@c000000 {
            compatible = "sifive,plic-1.0.0";
            reg = <0x0 0x0c000000 0x0 0x04000000>,
		  <0x0 0x2FF60000 0x0 0xF>; /* TT MSI catcher */
            interrupts-extended = <&cpu0_intc 11>, <&cpu0_intc 9>, <&cpu1_intc 11>, <&cpu1_intc 9>,
                                  <&cpu2_intc 11>, <&cpu2_intc 9>, <&cpu3_intc 11>, <&cpu3_intc 9>;
            interrupt-controller;
            #interrupt-cells = <1>;
            #address-cells = <0>;
            riscv,ndev = <128>;
        };

        ccache: cache-controller@2010000 {
            compatible = "starfive,jh7100-ccache", "cache";
            cache-block-size = <64>;
            cache-level = <2>;
            cache-sets = <2048>;
            cache-size = <2097152>;
            cache-unified;
            interrupt-parent = <&plic>;
            interrupts = <1>, <3>, <4>, <2>;
            reg = <0x0 0x2010000 0x0 0x1000>;
	        status = "disabled";
        };

        uart@2030000000 {
            compatible = "ns16550a";
            reg = <0x20 0x30000000 0x0 0x100>;
            reg-shift = <0x2>;
            reg-io-width = <0x4>;
            clock-frequency = <0x2FAF080>;
            current-speed = <460800>;
            status = "disabled"; // no physical UART in scrappy
        };

    };

    
    pcie@2032200000 {
        //compatible = "snps,dw-pcie-ecam";
        compatible = "tt,bh-pcie";
        #address-cells = <3>;
        #size-cells = <2>;
        device_type = "pci";
        bus-range = <0x0 0x4>;
        reg = <0x20 0x32200000 0x0 0x100000>,
                <0x20 0x31600000 0x0 0x100000>;
        reg-names = "config", "dbi";
        //ranges =     <0x02000000 0x0  0x0   0x20 0x32400000 0     0x4000>; // 16KB BAR
        ranges = <0x02000000 0x0    0x0        0x20   0x32400000 0 0x40000000>; // 1GB BAR
        // dma-ranges = <0x02000000 0x4820 0x30000000 0x4820 0x30000000 0 0x10000000>; // 256MB
        /*
        blackhole-thing runs:
    pcie_tile.configure_inbound_iatu(0, 0, 0x20'3000'0000ULL, 0xFFFF'FFFF);

    The 0x20'0000'0000 part of that lands them in BH's
        first 4GiB inbound TLB window, which should be aimed at L2CPU address
        0x4000'0000'0000.  The 3000'0000 part is because the L2CPU's DRAM is at
        0x4000'3000'0000, but we can't aim the 4GiB inbound TLB window directly
        at it -- so BH inbound iATU deals with adding this offset.
    */
        dma-ranges = <0x02000000 0 0 0x4000 0x30000000 0x0 0xD0000000>;
        //dma-ranges = <0x02000000 0 0 0x4000 0x30000000 0x0 0x80000000>;
        #interrupt-cells = <1>;
        interrupt-parent = <&plic>;
        interrupts = <6>;
        interrupt-names = "msi";
        interrupt-map-mask = <0x0 0x0 0x0 0x7>;
        interrupt-map = <0x0 0x0 0x0 0x1 &plic 6>;
    };
    
    msi: irqchip@2FFF60000 {
        compatible = "vendor,msi-catcherX";
	    // msi_catcher_cntl
	    // addr: 2FF6_0000 size: 16 bytes
	    reg = <0x0 0x2FF60000 0 0xF>;
        interrupt-parent = <&plic>;
        interrupts = <6>,<7>;
    };

};
